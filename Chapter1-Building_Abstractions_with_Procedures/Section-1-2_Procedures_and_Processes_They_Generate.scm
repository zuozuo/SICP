; 1.2.1 Example Factorial
(define (factorial n) 
  (if (= n 1)
      1
      (* n (factorial (- n 1)))
  ))
(display (factorial 4))
(newline)



; Exercise 1.9
; Each of the following two procedures defines a method for adding two positive integers in terms 
; of the procedures inc, which increments its argument by 1, and dec, which decrements its argument by 1.
(define (+ a b)
  (if (= a 0)
      b
      (inc (+ (dec a) b))))
(define (+ a b)
  (if (= a 0)
      b
      (+ (dec a) (inc b))))
; Using the substitution model, illustrate the process generated by each procedure in evaluating (+ 4 5).
; Are these processes iterative or recursive?

; Answer 1.9:
;
; (+ 4 5)
; (inc (+ 3 5))
; (inc (inc (+ 2 5)))
; (inc (inc (inc (+ 1 5))))
; (inc (inc (inc (inc (+ 0 5)))))
; (inc (inc (inc (inc 5))))
; (inc (inc (inc 6)))
; (inc (inc 7))
; (inc 8)
; 9
;
; The process generated by the first + procedure is above, and obviously it's a linear recursive process
;
; (+ 4 5)
; (+ 3 6)
; (+ 2 7)
; (+ 1 8)
; (+ 0 9)
; 9
;
; The process generated by the second + procedure is above, and obviously it's a linear iterative process



; Exercise 1.10
; The following procedure computes a mathematical function called Ackermann's function.
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))
; What are the values of the following expressions?
(A 1 10)
(A 2 4)
(A 3 3)
; Consider the following procedures, where A is the procedure defined above:
(define (f n) (A 0 n))
(define (g n) (A 1 n))
(define (h n) (A 2 n))
(define (k n) (* 5 n n))
; Give concise mathematical definitions for the functions computed by the procedures 
; f, g, and h for positive integer values of n. For example, (k n) computes 5*n^2.
; 
; Answer 1.10:
; (A 1 10)    =>         1024
; (A 2 4)     =>         65536
; (A 3 3)     =>         65536
;
(define (f n) (* 2 n))                ; f(n) = 2*n
(define (g n) (expt 2 n))             ; g(n) = 2^n
(define (h n)                         ; if n=1, f(n) = 2, if n>1, f(n) = 2^f(n-1)
  (if (= n 1)
      2
      (expt 2 (h (- n 1)))
  ))



; Section 1.2.2
; Example compute fibonacci numbers
(define (fib n) 
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (+ (fib (- n 1)) (fib (- n 2)))
        ))

(define (fib n) (fib-iter 1 0 n))
(define (fib-iter a b count) 
  (cond ((= count 0) b)
       ((= count 1) a)
       (else (fib-iter (+ a b) a (- count 1)))))



; Example Counting Change
(define (count-change amount) (change amount 5))
(define (change amount coin_number) 
  (cond ((= amount 0) 1)
        ((or (< amount 0) (<= coin_number 0)) 0)
        (else (+ (change amount (- coin_number 1)) (change (- amount (value_of_coin coin_number)) coin_number)))))

(define (value_of_coin coin_number) 
  (cond ((= coin_number 1) 1)
        ((= coin_number 2) 5)
        ((= coin_number 3) 10)
        ((= coin_number 4) 25)
        ((= coin_number 5) 50)
        (else 0)))



; Exercise 1.11
; A function f is defined by the rule that f(n) = n if n<3 and f(n) = f(n - 1) + 2f(n - 2) + 3f(n - 3) if n> 3.
; Write a procedure that computes f by means of a recursive process. 
; Write a procedure that computes f by means of an iterative process.
;
(define (recursive-f n) 
  (if (< n 3)
      n
      (+ (recursive-f (- n 1)) 
         (* 2 (recursive-f (- n 2))) 
         (* 3 (recursive-f (- n 3))))))

(define (iterative-f n) 
  (define (i-f a b c count) 
    (cond ((= count 0) c)
          ((= count 1) b)
          ((= count 2) a)
          (else (i-f (+ a (* 2 b) (* 3 c)) a b (- count 1)))))
  (i-f 2 1 0 n))



; Exercise 1.12
; The following pattern of numbers is called Pascal's triangle.
;                            1
;                           1 1
;                          1 2 1
;                         1 3 3 1
;                        1 4 6 4 1
;                           ...
;
;The numbers at the edge of the triangle are all 1, and each number inside the triangle is the sum of the two
;numbers above it. Write a procedure that computes elements of Pascal's triangle by means of a recursive process.
(define (pascal-triangle n) 
  (pascal-triangle-iter 1 n))
(define (pascal-triangle-iter start end) 
  (display-layer start 1)
  (if (= end start)
      (newline)
      (pascal-triangle-iter (+ start 1) end)
  ))
(define (triangle-element x y) 
  (if (or (= y 1) (= x y))
      1
      (+ (triangle-element (- x 1) (- y 1)) 
         (triangle-element (- x 1) y))
  ))
(define (display-layer n y) 
  (display (triangle-element n y))
  (display " ")
  (if (= y n)
      (newline)
      (display-layer n (+ y 1))
  ))
(pascal-triangle 5)



; Section 1.2.4 Exponentiation
; 
; Example computing the exponential of a given number
(define (expt b n) 
  (if (= n 0)
      1
      (* b (expt b (- n 1)))
  ))

(define (expt1 b n) 
  (expt-iter b n 1))

(define (expt-iter b count prod) 
  (if (= count 0)
      prod
      (expt-iter b (- count 1) (* b prod))
  ))

(define (fast-expt b n) 
  (cond ((= n 0) 1)
        ((even? n) (square (fast-expt b (/ n 2))))
        ((odd? n) (* b (fast-expt b (- n 1))))
        (else 0)))

(define (square n) (* n n))

; Exercise 1.16:
; Design a procedure that evolves an iterative exponentiation process that uses successive 
; squaring and uses a logarithmic number of steps, as does fast-expt. (Hint: Using the observation that
; (bn/2)2 = (b2)n/2, keep, along with the exponent n and the base b, an additional state variable a, 
; and define the state transformation in such a way that the product a bn is unchanged from state to state.
; At the ; beginning of the process a is taken to be 1, and the answer is given by the value of a at the end 
; of the process. In general, the technique of defining an invariant quantity that remains unchanged from state 
; to state is a powerful way to think about the design of iterative algorithms.)
; 
(define (fast-expt1 b n) 
  (if (even? n)
      (/ (fast-expt-iter b n b) b)
      (fast-expt-iter b n 1)
  ))
(define (fast-expt-iter b count prod) 
  (cond ((= count 0) prod)
        ((even? count) (fast-expt-iter (* b b) (/ count 2) prod))
        ((odd? count) (fast-expt-iter b (- count 1) (* b prod)))
        (else 0)))



; Exercise 1.17: 
; The exponentiation algorithms in this section are based on performing exponentiation by means of repeated 
; multiplication. In a similar way, one can perform integer multiplication by means of repeated addition. 
; The following multiplication procedure (in which it is assumed that our language can only add, not multiply)
; is analogous to the expt procedure:
(define (* a b)
  (if (= b 0)
      0
      (+ a (* a (- b 1)))))
; This algorithm takes a number of steps that is linear in b. Now suppose we include, together with addition,
; operations double, which doubles an integer, and halve, which divides an (even) integer by 2. Using these,
; design a multiplication procedure analogous to fast-expt that uses a logarithmic number of steps.
; Answer:
(define (double x) (+ x x))
(define (halve x) (/ x 2))
(define (fast-multiple a b) 
  (cond ((= b 0) 0)
        ((even? b) (fast-multiple (double a) (halve b)))
        (else (+ a (fast-multiple a (- b 1))))))



; Exercise 1.18: 
; Using the results of exercises 1.16 and 1.17, devise a procedure that generates an iterative process for multiplying 
; two integers in terms of adding, doubling, and halving and uses a logarithmic number of steps
(define (multiply a b) 
  (multiply-iter a b 0))
(define (double x) (+ x x))
(define (halve x) (/ x 2))
(define (multiply-iter a b prod) 
  (cond ((= b 0) prod)
        ((even? b) (multiply-iter (double a) (halve b) prod))
        (else (multiply-iter a (- b 1) (+ prod a)))))




